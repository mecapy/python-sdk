version: '3'

# Taskfile for go-task (https://taskfile.dev)
# Provides common developer workflows for this Python SDK project.

vars:
  SDK_MODULE: mecapy
  # Reusable version calculation scripts
  GET_CURRENT_VERSION: |
    if git describe --tags --abbrev=0 >/dev/null 2>&1; then
      git describe --tags --abbrev=0 | sed 's/^v//'
    else
      echo "0.0.0"
    fi
  CALCULATE_VERSION: |
    CURRENT="${CURRENT_VERSION}"
    BUMP_TYPE="${VERSION_TYPE}"

    # Parse current version
    IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"

    case "$BUMP_TYPE" in
      "major")
        echo "$((MAJOR + 1)).0.0"
        ;;
      "minor")
        echo "${MAJOR}.$((MINOR + 1)).0"
        ;;
      "patch")
        echo "${MAJOR}.${MINOR}.$((PATCH + 1))"
        ;;
      *)
        echo "Error: Invalid bump type: $BUMP_TYPE" >&2
        exit 1
        ;;
    esac

# Load environment from local files when present
dotenv: [ "dev/env.local" ]
silent: true

tasks:
  default:
    desc: "Show available tasks"
    cmds:
      - task --list

  check:
    desc: "Run all quality checks (lint with ruff, typecheck with mypy)"
    deps: [ install ]
    cmds:
      - uv run ruff check .
      - uv run mypy {{.SDK_MODULE}}

  format:
    desc: "Format code with ruff and fix check"
    deps: [ install ]
    cmds:
      - uv run ruff format .
      - uv run ruff check --fix --exit-zero .

  install:
    desc: "Install project dependencies (uses uv if available, falls back to pip)"
    cmds:
      - |
        if command -v uv >/dev/null 2>&1; then
          echo "Using uv to sync dependencies..."
          uv sync --group dev
        else
          echo "uv not found, using pip (editable + dev extras)..."
          python -m pip install --upgrade pip
          pip install -e ".[dev]"
        fi

  test:
    desc: "Run all batch tests"
    deps: [ install, "test:unit" ]

  test:unit:
    desc: "Run unit tests only"
    deps: [ install ]
    cmds:
      - uv run pytest -m unit -q

  test:interactive:
    desc: "Run interactive tests only"
    deps: [ install ]
    cmds:
      - uv run pytest -m interactive -q

  test:not_production:
    desc: "Run all tests except production"
    deps: [ install ]
    cmds:
      - uv run pytest -m "not production" -q

  build:
    desc: "Build wheel and sdist using hatchling (via uv if available)"
    deps: [ install, "_version:reset" ]
    cmds:
      - uv build

  clean:
    desc: "Clean build, cache and test artifacts"
    cmds:
      - rm -rf dist build *.egg-info .mypy_cache .ruff_cache .pytest_cache .coverage coverage_html htmlcov coverage.xml

  # Pre-commit hooks
  precommit:install:
    desc: "Install pre-commit hooks (includes automatic task format on commit)"
    deps: [ install ]
    cmds:
      - |
        echo "ðŸ”§ Installing pre-commit hooks..."
        uv run pre-commit install
        echo "âœ… Pre-commit hooks installed!"

  precommit:run:
    desc: "Run pre-commit hooks on all files"
    deps: [ install ]
    cmds:
      - uv run pre-commit run --all-files

  precommit:update:
    desc: "Update pre-commit hooks to latest versions"
    deps: [ install ]
    cmds:
      - uv run pre-commit autoupdate

  # Package publication helpers
  publish:test:
    desc: "Publish package to TestPyPI"
    deps: [ build ]
    cmds:
      - uv run twine upload --repository testpypi dist/*

  publish:prod:
    desc: "Publish package to PyPI (production)"
    deps: [ build ]
    cmds:
      - uv run twine upload dist/*

  init:
    desc: "Initialize development environment with uv and Python"
    cmds:
      - |
        echo "ðŸš€ Initializing development environment..."
        if ! command -v uv >/dev/null 2>&1; then
          echo "Installing uv..."
          curl -LsSf https://astral.sh/uv/install.sh | sh
          export PATH="$HOME/.cargo/bin:$PATH"
        fi
        echo "Using Python version from .python-version file..."
        uv python install $(cat .python-version)
        echo "Creating virtual environment..."
        uv venv --python $(cat .python-version)
        echo "Installing dependencies..."
        uv sync --group dev
        echo "âœ… Environment initialized successfully!"
        if ! command -v task >/dev/null 2>&1; then
          echo "Installing task..."
          sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d
        fi
        task precommit:install:

  version:
    desc: "Show current version information"
    cmds:
      - |
        echo "ðŸ“¦ Version Information:"
        echo "===================="

        # Check git status
        if ! git diff-index --quiet HEAD -- 2>/dev/null; then
          echo "âš ï¸  Working directory has uncommitted changes"
          GIT_STATUS="dirty"
        else
          echo "âœ… Working directory is clean"
          GIT_STATUS="clean"
        fi
        echo ""

        # Get git tag version
        if git describe --tags --abbrev=0 >/dev/null 2>&1; then
          LATEST_TAG=$(git describe --tags --abbrev=0 | sed 's/^v//')
          echo "ðŸ·ï¸  Latest git tag: $LATEST_TAG"

          # Show git describe for more context
          GIT_DESCRIBE=$(git describe --tags --dirty 2>/dev/null || echo "unknown")
          echo "ðŸ“‹ Git describe: $GIT_DESCRIBE"
        else
          echo "ðŸ·ï¸  Latest git tag: No tags found"
        fi

        # Get installed package version
        echo -n "ðŸ“¦ Installed package: "
        INSTALLED_VERSION=$(uv run python -c "
        try:
            import importlib.metadata
            print(importlib.metadata.version('{{.SDK_MODULE}}-sdk'))
        except Exception as e:
            print('Not installed or error:', str(e))
        " 2>/dev/null)
        echo "$INSTALLED_VERSION"

        # Explain version behavior
        if [ "$GIT_STATUS" = "dirty" ]; then
          echo ""
          echo "ðŸ’¡ Note: Installed package shows dev version because working directory has uncommitted changes."
          echo "   To get tag version, commit changes and run 'task version:sync'"
        fi

        # Get build version (if dist exists)
        if [ -d "dist" ] && [ "$(ls -A dist 2>/dev/null)" ]; then
          BUILT_VERSION=$(ls dist/*.whl 2>/dev/null | head -1 | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+' | head -1)
          if [ -n "$BUILT_VERSION" ]; then
            echo "ðŸ”¨ Last built: $BUILT_VERSION"
          fi
        fi

  _version:reset:
    internal: true
    desc: "Force complete version reset (clears all caches and rebuilds)"
    cmds:
      - |
        echo "ðŸ§¹ Performing complete version reset..."
        echo "ðŸ—‘ï¸  Cleaning build artifacts and caches..."
        rm -rf build/ dist/ *.egg-info/ .eggs/
        echo "ðŸ—‘ï¸  Uninstalling current package..."
        uv pip uninstall mecapy-sdk --quiet || true
        echo "ðŸ”„ Reinstalling with complete rebuild..."
        uv sync --group dev --reinstall
        echo "âœ… Version completely reset and synchronized!"

  _version:validate:
    internal: true
    desc: "Internal validation for version creation"
    deps: [ install ]
    preconditions:
      - sh: 'git diff-index --quiet HEAD --'
        msg: 'Working directory has uncommitted changes. Please commit all changes before creating a version.'
    cmds:
      - |
        echo "ðŸ” Pre-release validation..."
        echo "=========================="

        echo "1ï¸âƒ£ Running quality checks (ruff + mypy)..."
        if ! task check; then
          echo "âŒ Quality checks failed! Please fix all issues before creating a new version."
          exit 1
        fi

        echo ""
        echo "2ï¸âƒ£ Running unit tests with coverage verification..."
        if ! task test:unit; then
          echo "âŒ Unit tests failed or coverage below required! Please fix tests and improve coverage."
          exit 1
        fi

  _version:get_current:
    internal: true
    desc: "Get current version from git tags"
    vars:
      CURRENT_VERSION:
        sh: '{{.GET_CURRENT_VERSION}}'
    cmds:
      - echo "{{.CURRENT_VERSION}}"

  _version:calculate_next:
    internal: true
    desc: "Calculate next version based on bump type"
    vars:
      VERSION_TYPE: '{{.VERSION_TYPE | default "patch"}}'
      CURRENT_VERSION:
        sh: '{{.GET_CURRENT_VERSION}}'
      NEW_VERSION:
        sh: |
          CURRENT_VERSION="{{.CURRENT_VERSION}}"
          VERSION_TYPE="{{.VERSION_TYPE}}"
          {{.CALCULATE_VERSION}}
    cmds:
      - echo "{{.NEW_VERSION}}"

  _version:create:
    internal: true
    desc: "Internal version creation workflow"
    vars:
      VERSION_TYPE: '{{.VERSION_TYPE | default "patch"}}'
      CURRENT_VERSION:
        sh: '{{.GET_CURRENT_VERSION}}'
      NEW_VERSION:
        sh: |
          CURRENT_VERSION="{{.CURRENT_VERSION}}"
          VERSION_TYPE="{{.VERSION_TYPE}}"
          {{.CALCULATE_VERSION}}
    deps: [ "_version:validate" ]
    cmds:
      - |
        echo "--> All validations passed! Creating {{.VERSION_TYPE}} version..."

        echo "--> Creating version tag {{.NEW_VERSION}}..."
        if git tag -a "v{{.NEW_VERSION}}" -m "Release version {{.NEW_VERSION}}"; then
          echo "    |--> Version {{.NEW_VERSION}} tagged successfully!"
        else
          echo "    |--> Failed to create tag v{{.NEW_VERSION}}"
          exit 1
        fi

        echo ""
        echo "--> Building package with new version..."
        task build

        echo ""
        echo "--> Next steps:"
        echo "    |--> Push the tag: git push origin v{{.NEW_VERSION}}"
        echo "    |--> Publish to PyPI: task publish:prod"

  version:new:major:
    desc: "Create new major version (X.0.0) with quality and test validation"
    cmds:
      - task: "_version:create"
        vars:
          VERSION_TYPE: major

  version:new:minor:
    desc: "Create new minor version (x.Y.0) with quality and test validation"
    cmds:
      - task: "_version:create"
        vars:
          VERSION_TYPE: minor

  version:new:patch:
    desc: "Create new patch version (x.y.Z) with quality and test validation"
    cmds:
      - task: "_version:create"
        vars:
          VERSION_TYPE: patch

  version:preview:major:
    desc: "Preview what major version increment would create (dry-run)"
    vars:
      CURRENT_VERSION:
        sh: '{{.GET_CURRENT_VERSION}}'
      NEW_VERSION:
        sh: |
          CURRENT_VERSION="{{.CURRENT_VERSION}}"
          VERSION_TYPE="major"
          {{.CALCULATE_VERSION}}
    cmds:
      - |
        echo "ðŸ“¦ Current version: {{.CURRENT_VERSION}}"
        echo "ðŸ“¦ New version: {{.NEW_VERSION}}"

  version:preview:minor:
    desc: "Preview what minor version increment would create (dry-run)"
    vars:
      CURRENT_VERSION:
        sh: '{{.GET_CURRENT_VERSION}}'
      NEW_VERSION:
        sh: |
          CURRENT_VERSION="{{.CURRENT_VERSION}}"
          VERSION_TYPE="minor"
          {{.CALCULATE_VERSION}}
    cmds:
      - |
        echo "ðŸ“¦ Current version: {{.CURRENT_VERSION}}"
        echo "ðŸ“¦ New version: {{.NEW_VERSION}}"

  version:preview:patch:
    desc: "Preview what patch version increment would create (dry-run)"
    vars:
      CURRENT_VERSION:
        sh: '{{.GET_CURRENT_VERSION}}'
      NEW_VERSION:
        sh: |
          CURRENT_VERSION="{{.CURRENT_VERSION}}"
          VERSION_TYPE="patch"
          {{.CALCULATE_VERSION}}
    cmds:
      - |
        echo "ðŸ“¦ Current version: {{.CURRENT_VERSION}}"
        echo "ðŸ“¦ New version: {{.NEW_VERSION}}"

  # Lock file management
  lock:
    desc: "Update lock file after dependency changes"
    cmds:
      - uv lock
